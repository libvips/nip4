
/* Try to make a Matrix ... works for Vector/Image/Real, plus image/real
 */
to_matrix x
    = to_matrix x.expr, is_Expression x
    = x, is_Matrix x
    = oo_unary_function to_matrix_op x, is_class x
    = tom x
{
    to_matrix_op = Operator "to_matrix" tom Operator_type.COMPOUND false;

    tom x
        = Matrix (itom x), is_image x
        = Matrix [[x]], is_real x
        = Matrix [x], is_real_list x
        = Matrix x, is_matrix x
        = error (_ "bad arguments to " ++ "to_matrix");

    itom i
        = (im_vips2mask ((double) i)).value, is_image i
        = error (_ "not image");
}

/* Try to make a Vector ... works for Vector/Image/Real, plus image/real
 */
to_vector x
    = to_vector x.expr, is_Expression x
    = x, is_Vector x
    = oo_unary_function to_vector_op x, is_class x
    = tov x
{
    to_vector_op = Operator "to_vector" tov Operator_type.COMPOUND false;

    tov x
        = Vector (itov x), is_image x
        = Vector [x], is_real x
        = Vector x, is_real_list x
        = Vector x?0, is_matrix x && len x == 1
        = Vector (transpose x)?0, is_matrix x && len x?0 == 1
        = error (_ "bad arguments to " ++ "to_vector");

    itov i
        = v, is_image i
        = error (_ "not image")
    {
        m = im_vips2mask ((double) i);
        v
            = m.value?0, m.height == 1
            = (transpose m.value)?0, m.width == 1
            = error (_ "image is not 1xN or Nx1");
    }
}

/* Try to make an Image ... works for Vector/Matrix/Real, plus image/real
 * Special case for Colour ... pull out the colour_space and set Type in the
 * image.
 */
to_image x
    = to_image x.expr, is_Expression x
    = Image x.value, is_Plot x
    = x, is_Image x
    = Image (set_header $interpretation
            (Interpretation.get_value x.colour_space)
            (mtoi [x.value])),
        is_Colour x
    = oo_unary_function to_image_op x, is_class x
    = toi x
{
    to_image_op = Operator "to_image" toi Operator_type.COMPOUND false;

    toi x
        = Image x, is_image x
        = Image (mtoi [[x]]), is_real x
        = Image (mtoi [x]), is_real_list x
        = Image (mtoi x), is_matrix x
        = error (_ "bad arguments to " ++ "to_image");

    // [[real]] -> image
    mtoi m
        = im_mask2vips (Matrix m), width != 3
        = joinup (im_mask2vips (Matrix m))
    {
        width = len m?0;
        height = len m;
        joinup i
            = b1 ++ b2 ++ b3
        {
            b1 = crop 0 0 1 height i;
            b2 = crop 1 0 1 height i;
            b3 = crop 2 0 1 height i;
        }
    }
}

// like to_image, but we do 1x1 pixel + x, then embed it up
// always make an unwrapped image for speed ... this gets used by ifthenelse
// and stuff like that
// format can be NULL, meaning set format from x
to_image_size width height bands format x
    = x, is_image x
    = x.value, is_Image x
    = image_new [
        $bands => bands,
        $format => format',
        $pixel => x
    ] width height
{
    format'
        = get_format x, format == NULL
        = format;
}

/* Try to make a Colour.
 */
to_colour x
    = to_colour x.expr, is_Expression x
    = x, is_Colour x
    = to_colour (crop x.left x.top 1 1 x.image), is_Mark x
    = oo_unary_function to_colour_op x, is_class x
    = toc x
{
    to_colour_op = Operator "to_colour" toc Operator_type.COMPOUND false;

    toc x
        = Colour (colour_space (get_interpretation x''))
            (map mean (bandsplit (get_image x''))),
            has_image x && has_interpretation x
        = Colour "sRGB" [x, x, x], is_real x    // since Colour can't do mono
        = Colour "sRGB" x, is_real_list x && is_list_len 3 x
        = map toc x, is_matrix x
        = error (_ "bad arguments to " ++ "to_colour")
    {
        x'
            = x,
                Interpretation_3ary.has_value (get_interpretation x)
            = colour_transform_to Interpretation.sRGB x;
        x''
            = extract_bands 0 3 x', get_bands x' > 3
            = x';
    }

    colour_space interpretation
        = Interpretation_3ary.get_key interpretation,
            Interpretation_3ary.has_key interpretation
        = error (_ "unable to make Colour from " ++
                    Interpretation.get_name interpretation ++
                    _ " image");
}

/* Try to make a real. (not a Real!)
 */
to_real x
    = to_real x.expr, is_Expression x
    = oo_unary_function to_real_op x, is_class x
    = tor x
{
    to_real_op = Operator "to_real" tor Operator_type.COMPOUND false;

    tor x
        = x, is_real x
        = abs x, is_complex x
        = 1, is_bool x && x
        = 0, is_bool x && !x
        = error (_ "bad arguments to " ++ "to_real");
}

to_int x = (int) (to_real x);

/* Try to make a list ... ungroup, basically. We remove the innermost layer of
 * Groups.
 */
to_list x
    = x.value, is_Group x && !contains_Group x.value
    = Group (map to_list x.value), is_Group x
    = x;

/* Try to make a group. The outermost list objects become Group()'d.
 */
to_group x
    = Group x, is_list x
    = Group (map to_group x.value), is_Group x
    = x;

/* Parse a positive integer.
 */
parse_pint l
    = foldl acc 0 l
{
    acc sofar ch = sofar * 10 + parse_c ch;

    /* Turn a char digit to a number.
     */
    parse_c ch
        = error (_ "not a digit"), !is_digit ch
        = (int) ch - (int) '0';
}

/* Parse an integer, with an optional sign character.
 */
parse_int l
    = error (_ "badly formed number"), !is_list_len 2 parts
    = sign * n
{
    parts = splitpl [member "+-", is_digit] l;

    n = parse_pint parts?1;
    sign
        = 1, parts?0 == [] || parts?0 == "+"
        = -1;
}

/* Parse a float.
 *  [+-]?[0-9]*([.][0-9]*)?(e[0-9]+)?
 */
parse_float l
    = err, !is_list_len 4 parts
    = sign * (abs ipart + fpart) * 10 ** exp
{
    err = error (_ "badly formed number");

    parts = splitpl [
        member "+-0123456789",
        member ".0123456789",
        member "eE",
        member "+-0123456789"
    ] l;

    ipart = parse_int parts?0;
    sign
        = 1, ipart >= 0
        = -1;
    fpart
        = 0, parts?1 == [];
        = err, parts?1?0 != '.'
        = parse_pint (tl parts?1) / 10 ** (len parts?1 - 1);
    exp
        = 0, parts?2 == [] && parts?3 == []
        = err, parts?2 == []
        = parse_int parts?3;

}

/* Parse a time in "hh:mm:ss" into seconds.

We could do this in one line :)

    = (sum @ map2 multiply (iterate (multiply 60) 1) @ reverse @ map
    parse_pint @ map (subscript (splitpl [is_digit, equal ':', is_digit,
    equal ':', is_digit] l))) [0,2,4];

but it's totally unreadable.

 */
parse_time l
    = error (_ "badly formed time"), !is_list_len 5 parts
    = s + 60 * m + 60 * 60 * h
{
    parts = splitpl [is_digit, equal ':', is_digit, equal ':', is_digit] l;
    h = parse_int parts?0;
    m = parse_int parts?2;
    s = parse_int parts?4;
}

D93_whitepoint = Vector [89.7400, 100, 130.7700];
D75_whitepoint = Vector [94.9682, 100, 122.5710];
D65_whitepoint = Vector [95.0470, 100, 108.8827];
D55_whitepoint = Vector [95.6831, 100, 92.0871];
D50_whitepoint = Vector [96.4250, 100, 82.4680];
A_whitepoint = Vector [109.8503, 100, 35.5849];     // 2856K
B_whitepoint = Vector [99.0720, 100, 85.2230];      // 4874K
C_whitepoint = Vector [98.0700, 100, 118.2300];     // 6774K
E_whitepoint = Vector [100, 100, 100];          // ill. free
D3250_whitepoint = Vector [105.6590, 100, 45.8501];

Whitepoints = class Enum {
    D93 = D93_whitepoint;
    D75 = D75_whitepoint;
    D65 = D65_whitepoint;
    D55 = D55_whitepoint;
    D50 = D50_whitepoint;
    A = A_whitepoint;
    B = B_whitepoint;
    C = C_whitepoint;
    E = E_whitepoint;
    D3250 = D3250_whitepoint;

    _description = [
        [A, _"CIE A (2850K)"],
        [B, _"CIE B (4874K)"],
        [C, _"CIE C (6774K)"],
        [E, _"CIE E (illuminant free)"]
    ];
};

/* FIXME .. remove these and use colourspace directly.
 */
colour_transform from to in = colourspace [$source_space => from] to in;
colour_transform_to to in = colourspace [] to in;

/* String for path separator on this platform.
 */
path_separator = expand "$SEP";

/* Form a relative pathname.
 *  path_relative ["home", "john"] == "home/john"
 *  path_relative [] == ""
 */
path_relative l = joinsep path_separator l;

/* Form an absolute pathname.
 *  path_absolute ["home", "john"] == "/home/john"
 *  path_absolute [] == "/"
 * If the first component looks like 'A:', don't add an initial separator.
 */
path_absolute l
    = path_relative l,
        len l?0 > 1 && is_letter l?0?0 && l?0?1 == ':'
    = path_separator ++ path_relative l;

/* Parse a pathname.
 *  path_parse "/home/john" == ["home", "john"]
 *  path_parse "home/john" == ["home", "john"]
 */
path_parse str
    = split (equal path_separator?0) str;

/* Return $PATH, reformatted as [["comp1", "comp2"], ["comp1", "comp2"] ..]
 */
system_search_path
    = [vipsbin] ++
        map path_parse (split (equal path_sep) (expand "$PATH"))
{
    /* On some platforms we ship vips with a few extra progs. Search
     * $VIPSHOME/bin first.
     */
    vipsbin = path_parse (expand "$VIPSHOME") ++ ["bin"];

    path_sep
        = ':', expand "$SEP" == "/"
        = ';';
}

/* Search $PATH for the first occurence of name, or "".
 */
search_for name
    = hits?0, hits != []
    = ""
{
    exe_name = name ++ expand "$EXEEXT";
    form_path p = path_absolute (p ++ [exe_name]);
    paths = map form_path system_search_path;
    hits = dropwhile (equal []) (map search paths);
}

/* Search $PATH for the first occurence of name, error on failure.
 */
search_for_error name
    = path, path != ""
    = error (exe_name ++ " not found on your search path. " ++
        "Check you have installed the program and it is on your PATH.")
{
    exe_name = name ++ expand "$EXEEXT";
    path = search_for name;
}

